{"version":3,"file":"compute-block.console.js","sourceRoot":"","sources":["../../src/console/compute-block.console.ts"],"names":[],"mappings":"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","sourcesContent":["import { PrismaService } from \"@root/prisma/prisma.service\";\nimport { imageUrlToBuffer } from \"@root/shared/helpers/image-url-to-buffer\";\nimport { Command, CommandRunner } from \"nest-commander\";\nimport sharp from \"sharp\";\n\nconst nftSizes = [1, 3, 3, 6, 8, 9, 10, 10, 10, 10, 20, 1];\n\nconst width = 360;\nconst height = width;\nconst channels = 3;\nconst whitePixel = 0xffffff;\n\nconst emptyCanvas = Buffer.alloc(width * height * channels, whitePixel); // single block\n\n@Command({\n  name: \"compute-block\",\n})\nexport class BlockConsole extends CommandRunner {\n  private memo = new Map<\"ids_1001\", string>();\n\n  constructor(private prisma: PrismaService) {\n    super();\n  }\n\n  async run(): Promise<void> {\n    while (true) {\n      const emptyImage = await sharp(emptyCanvas, {\n        raw: { width, height, channels },\n      })\n        .png()\n        .toBuffer();\n\n      const nfts = await this.prisma.nft.findMany({\n        where: {\n          is_active: true,\n        },\n        orderBy: [{ position: \"asc\" }, { id: \"desc\" }],\n      });\n\n      const ids = JSON.stringify(nfts.slice(0, 1001).map((x) => x.id));\n\n      if (this.memo.get(\"ids_1001\") === ids) {\n        return;\n      }\n\n      this.memo.set(\"ids_1001\", ids);\n\n      const imageBuffers = await Promise.all(\n        nfts.map(async (nft) => {\n          return imageUrlToBuffer(nft.image_url).catch(() => emptyImage);\n        }),\n      );\n\n      const compositeParamsList = [];\n\n      for (let blockNumber = 1; blockNumber <= 12; ++blockNumber) {\n        const size = nftSizes[blockNumber - 1]; //[1, 3, 3, 6, 8, 9, 10, 10, 10, 10, 20, 1]\n        const compositeParams = []; // signle block from size 1, 3, 3, 6 , 8 ...\n        const borderSize = Math.min(Math.ceil(width / size / 12), 9);\n\n        for (let idx = 0; idx < size * size; ++idx) {\n          let border = borderSize;\n          let imageBuffer: Buffer = emptyImage;\n\n          if (imageBuffers.length > 0) {\n            imageBuffer = imageBuffers.shift()!;\n            border = 0;\n          }\n          if (!imageBuffer) imageBuffer = emptyImage;\n\n          const buffer = await sharp(imageBuffer)\n            .resize({\n              width: width / size - border * 2,\n              height: width / size - border * 2,\n            })\n            .extend({\n              top: border,\n              bottom: border,\n              left: border,\n              right: border,\n              background: \"#E6F2F5\",\n            })\n            .toBuffer();\n\n          compositeParams.push({\n            input: buffer,\n            top: (width / size) * Math.trunc(idx / size),\n            left: (width / size) * Math.trunc(idx % size),\n          }); // piece of single block ( EX: block 12 includes 20x20 pieces, block 11 includes 10x10 pieces )\n        }\n\n        compositeParamsList.push(compositeParams); //list of 12 blocks\n      }\n\n      const outputBuffers = await Promise.all(\n        compositeParamsList.map(async (compositeParams) => {\n          return sharp(emptyImage).composite(compositeParams).png().toBuffer();\n        }),\n      ); // buffer of 12 blocks\n\n      await Promise.all(\n        outputBuffers.map(async (outputBuffer, idx) => {\n          sharp(outputBuffer).toFile(`public/block_${idx + 1}.png`);\n        }),\n      );\n    }\n  }\n}\n"]}